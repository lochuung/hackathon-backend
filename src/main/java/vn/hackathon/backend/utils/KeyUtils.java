package vn.hackathon.backend.utils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.security.spec.*;
import java.util.Base64;
import lombok.experimental.UtilityClass;

@UtilityClass
public class KeyUtils {
  public static final String PRIVATE_KEY_PATH = "keys/private_key.pem";
  public static final String PUBLIC_KEY_PATH = "keys/public_key.pem";

  /**
   * Loads an RSA KeyPair from disk if both PEM files exist; otherwise generates a new 2048-bit RSA
   * KeyPair, persists the private and public keys as PEM files, and returns the pair.
   *
   * <p>Side effects: may create the parent directories for the key files and write
   * keys/private_key.pem and keys/public_key.pem in PEM format.
   *
   * @return the loaded or newly generated RSA {@link KeyPair}
   * @throws Exception if reading, writing, parsing, or generating the keys fails
   */
  public static KeyPair loadOrCreateKeyPair() throws Exception {
    File privateKeyFile = new File(PRIVATE_KEY_PATH);
    File publicKeyFile = new File(PUBLIC_KEY_PATH);

    if (privateKeyFile.exists() && publicKeyFile.exists()) {
      // Load existing keys
      return new KeyPair(loadPublicKey(), loadPrivateKey());
    } else {
      // Create and save new keys
      KeyPair keyPair = generateRsaKeyPair();
      saveKeyAsPEM(PRIVATE_KEY_PATH, keyPair.getPrivate(), "PRIVATE KEY");
      saveKeyAsPEM(PUBLIC_KEY_PATH, keyPair.getPublic(), "PUBLIC KEY");
      return keyPair;
    }
  }

  /**
   * Generates a new 2048-bit RSA KeyPair.
   *
   * @return a newly generated RSA KeyPair (2048-bit)
   * @throws NoSuchAlgorithmException if the RSA algorithm is not available on the platform
   */
  private static KeyPair generateRsaKeyPair() throws NoSuchAlgorithmException {
    KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
    keyPairGen.initialize(2048);
    return keyPairGen.generateKeyPair();
  }

  /**
   * Writes a Key to disk in PEM format with the given PEM block type.
   *
   * <p>The method ensures the parent directories for the target path exist (throws IOException if
   * they cannot be created), encodes the key bytes using Base64, wraps lines at 64 characters, and
   * writes a PEM file with the standard "BEGIN/END {type}" delimiters.
   *
   * @param path filesystem path where the PEM file will be written
   * @param key the key to serialize (its encoded form is used)
   * @param type the PEM block type label (e.g., "PRIVATE KEY", "PUBLIC KEY")
   * @throws IOException if directories cannot be created or writing the file fails
   */
  private static void saveKeyAsPEM(String path, Key key, String type) throws IOException {
    File file = new File(path);
    boolean dirsCreated = file.getParentFile().mkdirs();
    if (!dirsCreated && !file.getParentFile().exists()) {
      throw new IOException("Failed to create directories for path: " + path);
    }

    String base64 = Base64.getEncoder().encodeToString(key.getEncoded());
    try (FileWriter writer = new FileWriter(file)) {
      writer.write("-----BEGIN " + type + "-----\n");
      writer.write(base64.replaceAll("(.{64})", "$1\n"));
      writer.write("\n-----END " + type + "-----\n");
    }
  }

  /**
   * Loads a PKCS#8 private RSA key from the PEM file at KeyUtils.PRIVATE_KEY_PATH.
   *
   * <p>The method reads the PEM file, strips the "-----BEGIN PRIVATE KEY-----" and "-----END
   * PRIVATE KEY-----" markers and any whitespace, Base64-decodes the remaining content, and builds
   * a PrivateKey using an RSA KeyFactory.
   *
   * @return the RSA PrivateKey parsed from the PEM file
   * @throws Exception if the file cannot be read, the PEM content is malformed, Base64 decoding
   *     fails, or the key cannot be generated by the RSA KeyFactory
   */
  private static PrivateKey loadPrivateKey() throws Exception {
    String keyPEM =
        new String(Files.readAllBytes(Paths.get(KeyUtils.PRIVATE_KEY_PATH)))
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replaceAll("\\s", "");

    byte[] decoded = Base64.getDecoder().decode(keyPEM);
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);
    return KeyFactory.getInstance("RSA").generatePrivate(spec);
  }

  /**
   * Loads the RSA public key from the PEM file at KeyUtils.PUBLIC_KEY_PATH.
   *
   * <p>Reads the PEM file, strips the "BEGIN/END PUBLIC KEY" markers and whitespace, Base64-decodes
   * the remainder, builds an X.509 key specification, and returns the resulting PublicKey.
   *
   * @return the RSA PublicKey loaded from the PEM file
   * @throws Exception if the file cannot be read or the key cannot be parsed/constructed
   */
  private static PublicKey loadPublicKey() throws Exception {
    String keyPEM =
        new String(Files.readAllBytes(Paths.get(KeyUtils.PUBLIC_KEY_PATH)))
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replaceAll("\\s", "");

    byte[] decoded = Base64.getDecoder().decode(keyPEM);
    X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);
    return KeyFactory.getInstance("RSA").generatePublic(spec);
  }
}
